# 5.高性能应用的策略

在本书的第一部分，我介绍了函数式编程背后的理论，概述了如何用函数式风格编写代码。我提到了函数式编程的一些好处，但在第二部分中，我将通过创建一些程序来展示函数式编程可以简化的一些实际任务，从而使这些好处加倍。

本章着眼于使用函数式编程来提高脚本的性能。在过去，PHP 在性能部门受到了不好的评价，这并不完全令人惊讶，因为它本质上是一种高级解释语言。然而，在过去的几个主要版本中，性能有了很大的提高，尤其是版本 7，它的性能远远超过了 PHP 以前的任何版本。所以，在你开始学习本章的技术之前，确保你运行的是最新版本的 PHP，因为这可能是提高性能最简单的方法。也就是说，即使您已经升级到了最新最好的版本，也经常会有这样的时候，您可以对有问题的脚本进行额外的性能提升。您将看到函数式编程技术，如记忆化和惰性求值，它们有助于提高脚本速度，以及函数式编程如何帮助您利用并行编程来提高性能。但是在开始之前，理解我所说的性能是什么以及如何衡量它是很重要的。

## 了解和衡量绩效

当您的脚本运行时，它将使用一定数量的内存和 CPU 和/或墙时间。其中任何一项的降低通常都被认为是性能的提高。有时，其他资源，如磁盘空间、网络带宽或 API 调用，也被认为是性能问题。您的特定性能要求将决定在什么情况下您认为性能得到了提高。例如，在具有大量磁盘空间但处理器有限的 NAS 机器上，您可能认为以增加缓存磁盘空间为代价来优化较低的内存和 CPU 使用是理想的。但是，如果您的目标是配备小型固态硬盘的高性能笔记本电脑，您可能会考虑使用内存，因为缓存存储是一种更好的权衡。在这一章中，你将主要关注内存使用和墙时间，这是 PHP 脚本经常遇到的两个最大的性能问题。

## 衡量绩效:剖析

您可能遇到过运行缓慢的脚本(通常是您自己的脚本！)，通常第一反应是开始寻找提高 PHP 速度的方法。编译、缓存、重构代码、加速器——这些都是在搜索 PHP 性能或速度问题时很容易出现的话题。你可能已经读到过它们，并想尝试一下。

我的建议(来自痛苦的个人经历)是立即停止。对您的代码抛出一个又一个性能技巧(通常您可以在网上或类似的好书中找到)，即使它们看起来很合理，并且您可以看到其中的逻辑，也可能会使您的代码变得复杂，或者无缘无故地增加依赖性。为什么呢？因为当你不知道问题的根本原因时，你就不知道一个特定的解决方案，不管在理论上有多好，是否能解决你在特定情况下遇到的问题。即使它看起来确实有效，你也不知道这是否是解决它的最简单的方法，因此当你不需要的时候，你是否会让自己背上额外的“技术债务”。

你经常错过的一步是直接问你的剧本“你怎么跑这么慢？”如果您的脚本告诉您，那么您可以尝试在不使用外部工具(如编译器和缓存系统)的情况下修复这个问题。那么，你如何向你的剧本提出为什么的问题呢？通过侧写。

分析器在软件运行时监视它(通常从“内部”)，并分解程序每个部分所用的时间(有时是资源)。概要文件信息通常被报告到单独的代码行或函数调用的级别。这有助于您准确定位脚本变慢的地方。是因为复杂数据库查询吗？写得不好的循环？一个被调用次数超过预期的函数？磁盘或网络访问暂停执行？无论是什么问题，侧写员都会告诉你。一旦你知道了减速的确切原因，解决方案通常是显而易见的(或者至少，你可以排除实际上不会解决问题的潜在解决方案)。这可能只是意味着重写几行代码或缓存一些数据，而不是重复生成数据。剖析器可能会指出 PHP 外部的问题，比如缓慢的数据库服务器或落后的网络连接或资源。当然，在某些情况下，从 PHP 编程的角度来看，您可能最终会遇到一个棘手的问题，这确实需要加速器或外部缓存系统的帮助。在任何情况下，通过在开始尝试什么之前使用一个分析器来询问为什么，您可能会节省时间并防止对您的代码或部署环境进行不必要的更改。

对于 PHP，在进行概要分析时，您有几种选择。您可以通过将分析/测量语句直接添加到您的代码库中来手动分析您的代码，或者您可以使用一个工具来自动分析您的代码。如果您大致知道问题出在代码的什么地方，那么前者简单快捷，不需要改变您的开发环境。后者虽然需要安装和配置该工具，并在第一次学习如何使用它，但它提供了更全面的分析。它也不依赖于您知道您的问题可能在哪里，并且通常只需要对您的代码库进行最小的修改或者不需要修改。在接下来的小节中，您将会看到这两个选项。

## 手动剖析

手动分析需要在源代码中添加代码，以便直接从脚本中测量时间或资源。清单 [5-1](#Par10) 展示了一个测量不同代码行执行时间的例子，输出如清单 [5-2](#Par11) 所示。

```
<?php

# A script to do some "busywork", filling
# some strings with some characters.

# Let's create a "checkpoint" by recording the current time and memory
# usage

$time1 = microtime(true);

$memory1 = memory_get_usage();

# Now let's do a loop 10 times, having a quick usleep and
# adding just a little data to our variable each time

$a_string = (function () {

  $output = '';

  for ($counter = 0; $counter < 10; $counter++) {

     usleep(10);

     $output .= 'a';

  };

  return $output;

})(); //we execute the function straight away

# Now create a second checkpoint

$memory2 = memory_get_usage();

$time2 = microtime(true);

# Let's do this second loop 1000 times, having a longer
# sleep and adding lots of data to our variable each time

$b_string = (function () {

  $output = '';

  for ($counter = 0; $counter < 10; $counter++) {

     usleep(100);

     $output .= str_repeat('abc',1000);

  };

  return $output;

})(); //again we execute straightaway

# and create a final checkpoint

$memory3 = memory_get_usage();

$time3 = microtime(true);

# Now let's output the time and memory used after each function.

echo "1st function : ".($time2-$time1)." secs, ".
    ($memory2-$memory1)." bytes\n";

echo "2nd function : ".($time3-$time2)." secs, ".
    ($memory3-$memory2)." bytes\n";

echo ("Peak memory usage : ". memory_get_peak_usage()." bytes\n");

Listing 5-1.manual.php

```

```
1st function : 0.0007178783416748 secs, 40 bytes
2nd function : 0.0016269683837891 secs, 32768 bytes
Peak memory usage : 392504 bytes
Listing 5-2.manual-output.txt

```

如您所见，第二个函数比第一个函数花费的时间长得多。你现在知道了使你的脚本变慢的问题是第二个循环，你可以通过删除`usleep`语句或者删除整个循环并用`str_repeat('abc',1000000)`填充你的字符串来修复它。

在查看每个函数调用前后使用的内存量时，您需要稍微谨慎一些。如您所见，第二个函数后内存使用的差异比第一个函数大得多，这是意料之中的，因为您已经返回了一个大字符串。但是，该脚本的内存使用峰值高于两个单独测量值的总和。函数在运行时会使用内存，但是一旦它们返回，内存通常会被释放(静态变量和生成器不会被释放)，只留下返回值所占用的内存(假设您选择了捕获它)。即使您在您的`return`语句之前添加了一个`memory_get_usage()`调用，如果您在函数执行时销毁或替换变量值，它也可能不会捕获函数使用的所有内存。在进行过程中，您需要仔细考虑您的脚本正在做什么，以及放置手动分析语句的最佳位置。

这显然是一个简单的、人为的例子，但是这些原则也适用于真实世界的代码。正如您所看到的，对于这里或那里的几行代码或一个函数，手动分析是快速而简单的。然而，分析较大的代码库很快会变得很麻烦，如果不小心的话，会大大增加代码库的大小。在寻找一个特定的问题时，您可以分析代码的较大部分，当发现有问题的较大部分时，您可以将它分析成较小的部分，等等，直到找到问题代码(有效地进行二分搜索法)。如果您花费大量的时间来这样做，那么实现和学习像下面详述的那些剖析工具所必需的时间可能会是值得的。

另一件要记住的事情是，手动分析代码会增加脚本的性能损失——虽然通常很小，但累积起来会很大，特别是在您不断重复地将分析信息记录到磁盘的情况下。因此，在代码投入生产之前(可能作为构建/部署过程的一部分)，考虑剥离或禁用概要分析代码是值得的。当然，在某些情况下，有意识地将概要分析代码添加到产品代码库可能会有所帮助(例如，当从您的终端用户那里收集概要分析信息是必要的/有用的时候，这些用户可能没有安装专用的概要分析软件)。自动分析工具通常也会增加一些开销，尽管它通常更小(它们通常是用低级语言编写的，并且通常直接与 PHP 解释器集成)，并且通常更容易打开和关闭。这些自动化工具通常只在开发环境中使用，而不在实际生产机器上使用，因此任何开销都仅限于开发工作。

## 分析工具

PHP 有几个可用的分析工具。虽然流行的 Xdebug 调试器提供了一些分析选项(如果您已经安装了用于调试的工具，那么值得一看)，但是最常见和最全面的工具是 XHProf。最初由脸书开发，它是 PECL 的扩展，因此可以简单方便地安装。数据收集端是用 C 编写的，提供了一个图形化的 PHP 接口，用于查看收集到的概要数据，包括调用图(哪些函数调用了哪些函数的可视化图形)，如果你安装了 Graphviz 的话。两个相关的项目 XHProf UI 和 XHGui 提供了一个扩展的可视化界面，在一个 MySQL 或 MongoDB 中存储多个运行，并提供对多个运行进行排序和比较的访问。这些需要安装和配置的工作要多一点，但是如果您经常在生产系统上分析开发代码或实时代码，它们会提供很大的灵活性。不过，对于在开发代码中发现明显问题的基本剖析，XHProf 本身是一个很好的起点。

领先的商业 PHP 分析工具是 Blackfire，它提供了相当全面的分析服务，并且在撰写本文时有一个合理的免费层。请注意，虽然分析客户端在您的系统上运行，但数据会报告给 Blackfire 服务器后端，因此可能不适合某些用途。

### 进一步阅读和工具

*   “对速度的需求:用 XHProf 和 XHGui 剖析 PHP ”,作者 Matt Turland
    *   [T2`https://www.sitepoint.com/the-need-for-speed-profiling-with-xhprof-and-xhgui/`](https://www.sitepoint.com/the-need-for-speed-profiling-with-xhprof-and-xhgui/)
*   Adam Culp 的“XHProf PHP 剖析”
    *   [T2`www.geekyboy.com/archives/718`](http://www.geekyboy.com/archives/718)
*   Lorna Mitchell 的“用 XHGui 分析 PHP 应用程序”
    *   [T2`https://inviqa.com/blog/profiling-xhgui`](https://inviqa.com/blog/profiling-xhgui)

XHProf 老师

函数级分层 PHP 分析器

*   主网站: [`https://github.com/phacility/xhprof`](https://github.com/phacility/xhprof)
*   安装信息:[`www.php.net/manual/en/xhprof.setup.php`T2】](http://www.php.net/manual/en/xhprof.setup.php)
*   主要文档: [`www.php.net/xhprof`](http://www.php.net/xhprof)
*   可视化函数图形工具: [`http://graphviz.org/`](http://graphviz.org/)

xh 教师 UI

基于 XHProf 的扩展分析器

*   主网站和文档: [`https://github.com/preinheimer/xhprof`](https://github.com/preinheimer/xhprof)

XHGUI

基于 MongoDB 的 XHProf 数据图形界面

*   主网站和文档: [`https://github.com/perftools/xhgui`](https://github.com/perftools/xhgui)

Xdebug

内置分析器的综合调试器

*   主网站和文档: [`https://xdebug.org/`](https://xdebug.org/)

KCachegrind

轮廓数据可视化工具。与 Xdebug 一起使用以获取可视配置文件信息。

*   主网站和文档: [`https://kcachegrind.github.io/html/Home.html`](https://kcachegrind.github.io/html/Home.html)

Webgrind

Xdebug 的另一个基于 web 的概要分析前端，它实现了 KCachegrind 功能的子集

*   主网站和文档: [`https://github.com/jokkedk/webgrind`](https://github.com/jokkedk/webgrind)

逆火

商业 PHP 分析服务

*   网址: [`https://blackfire.io/pricing`](https://blackfire.io/pricing)

## 低级剖析

当你真的需要“深入”你的脚本时，有时你需要看的不是你的代码在做什么，而是 PHP 本身在做什么。明确地说，我们大多数人永远不需要这样做来解决性能问题，尽管看一看 PHP 如何将您的代码翻译成对运行它的系统的调用是非常有趣和有益的。PHP 本身是一个编译成二进制可执行文件的 C 程序，这意味着您可以使用 strace(显示系统调用和信号)、ltrace(显示库调用)和 gdb(类似 PHP 本身的 C 程序调试器)等通用工具来查看幕后发生的事情。如果你对此感兴趣，可以看看吴镇男·雷森斯的以下教程。作为 Xdebug 的作者，他在某种程度上是 PHP 机制方面的专家。

所以，现在你已经剖析了你的代码，你知道你的瓶颈在哪里，你解决了任何简单的新手错误。您已经运行了最新版本的 PHP，并且您在顶层硬件上。因此，您相当确信您的问题出在代码库的特定部分，并且您需要以更有效的方式编写一些算法。函数式编程能提供一些模式来帮助加速你的代码吗？当然可以；否则，这将是一个非常短的章节！下面几节介绍了一些功能性技术，这些技术适用于许多情况，即使您的整个代码库都不起作用。

### 进一步阅读

*   “PHP 在做什么？”作者吴镇男·雷森斯
    *   [T2`http://derickrethans.nl/what-is-php-doing.html`](http://derickrethans.nl/what-is-php-doing.html)

## 记忆化

如果你已经编程一段时间了，特别是在 web 领域，你会遇到缓存的概念。缓存是这样一个过程，即获取“昂贵”计算的结果，存储结果，然后在下次调用该计算时使用存储的结果，而不是再次运行计算本身。昂贵意味着运行时间长，占用大量内存，进行大量外部 API 调用，或者执行任何其他出于成本或性能原因而希望最小化的操作。缓存失效是您选择从缓存中移除项目的过程。例如，如果生成新闻网站的首页需要很大的努力，那么您会希望缓存该页面，这样就不需要在每次访问者访问您的网站时都生成它。然而，一旦下一个突发事件发生，您将希望更新您的首页，并且您不希望您的访问者点击缓存版本并获得旧新闻，因此您将“无效”缓存并重新生成页面。如果您曾经参与编写或使用过缓存系统，您无疑会熟悉下面这句话(或者至少理解它的出处)，这句话引自 Phil Karlton:

"在计算机科学中只有两件困难的事情:命名、缓存失效和一个接一个的错误."

您已经看到了递归如何减少一个接一个的错误，而且没有人有希望解决事物命名的问题，那么如何解决缓存失效呢？如果你认为函数编程有锦囊妙计，请举手。很好，金星给你！确实如此，诀窍就是永远不要让缓存失效。问题解决了！

我其实是认真的。函数式编程提供了一种称为记忆化的技术，这种技术植根于纯函数固有的属性。在前面的理论章节中，你看到了纯函数是如何透明引用的。给定一组特定的输入参数，一个纯函数将总是产生相同的返回值，并且(对于该组输入)该函数可以简单地用返回值替换。这听起来应该有点像缓存:对于一组给定的输入(比如，您的新闻故事)，您希望用返回值(缓存的输出)替换(运行起来很昂贵的)函数。获取一个纯函数的输出并缓存它的过程是记忆化，是缓存的一个特例。

假设您正在记忆一个昂贵的函数，并将结果缓存到磁盘。每次使用不同的参数运行该函数时，可能会得到不同的结果。您想要消除的是对相同参数多次运行函数的成本，因为每次您的(纯)函数都保证给您相同的结果。因此，您可以缓存结果，例如，创建一个散列来表示所使用的输入参数，并使用它作为文件名来存储该运行的返回值。下次运行该函数时，再次散列输入参数，查看是否存在同名的缓存文件，如果存在，则返回内容(而不是重新运行代价高昂的函数)。

到目前为止，这是典型的缓存。但是，如何避免让缓存失效呢？答案是你没有；记忆能有效地帮你做到这一点。你的功能是纯的，这意味着没有副作用。因此，如果在你虚构的新闻网站上出现了一个新的故事，这个故事的细节将只影响(纯)函数，该函数通过输入参数创建你的首页。例如，您可以将一组标题作为一个参数。突然，参数的哈希值发生了变化，所以 memoized 函数将无法在磁盘上找到具有该哈希值的文件，因此将运行完整的函数，并将新结果缓存到磁盘上以新哈希值命名的文件中。概括地说，由于您唯一的输入是参数，如果没有任何参数发生变化，您必须确定可以使用缓存。但是，如果参数已经改变，那么就没有相应的缓存文件，所以没有必要使它无效。当然，旧的缓存文件仍然会在那里，所以当您不小心发布了一个谎称这本书是垃圾的故事时，您可以立即收回它，函数将返回到使用旧的缓存文件，因为哈希将再次匹配参数。

目前为止，一切顺利。然而，函数式编程并没有因为它的优点而止步，哦，不。如果你正在考虑如何编写你的函数来实现记忆，那就停下来吧。一般来说，你不需要。您可以简单地将您的函数包装在另一个自动记忆它的函数中。这样的包装函数很容易编写，因为你所关心的只是你的纯函数的输入和输出，而不是它在内部做什么。

让我们来看一个记忆的例子。在清单 [5-3](#Par62) 中，您将把 pure 函数的结果缓存到磁盘中。为了简洁起见，您将把那些不纯的磁盘函数分离成单独的函数，而不是编造一些 IO 单子，但是如果您愿意，当然也可以这样做。

```
<?php

# We're going to cache our results on disk, so let's
# define a directory and file prefix

define('CACHE_PREFIX', sys_get_temp_dir().'/memo-cache-');

# This is a helper function to read a cached file
# from disk. I've broken it out as a separate function
# as it is necessarily impure. You can replace it
# with an IO monad or similar in production if you wish

$get_value = function($hash) {

    # return null if the file doesn't exist

    if (!file_exists(CACHE_PREFIX.$hash)) { return null;  }

    # read the file into $value

    $value = file_get_contents(CACHE_PREFIX.$hash);

    # return null if the file exists but couldn't be read

    if ($value === false) { return null; }

    # return our value if all is good

    return $value;

};

# Likewise, this is an impure helper function to write
# the value to a cache file.

$store_value = function($hash, $value) {

    if (file_put_contents(CACHE_PREFIX.$hash, $value) === false) {

        $value = null;

    }

    # return the value that was stored, or null if the
    # storage failed

    return $value;

};

# Finally, this is our actual memoization function.
# It returns a closure which is a "memoized" version
# of the function you call it on, i.e. a version
# of your function which automatically caches return
# values and automatically uses those cached values
# without further coding from you.

# $func is the function (closure or other callable) that
# you want to memoize

$memoize = function($func) use ($get_value, $store_value)
{
        # We're returning a memoized function

    return function() use ($func, $get_value, $store_value)
    {

                # Get the parameters you (the end user) call
                # your memoized function with

        $params = func_get_args();

                # Get a unique hash of those parameters, to
                # use as our cache's key. We needs to convert
                # the params array to a string first, we use
                # json_encode rather than serialize here as
                # it is a lot faster in most cases

            $hash = sha1( json_encode( $params ) );

                # Check the cache for any return value that
                # has already been cached for that particular
                # set of input parameters (as identified by
                # its hash)

                $value = $get_value($hash);

                # If there was no pre-cached version available,
                # $value will be null. We check this with the ??
                # null coalescing operator, returning either :
                # a) the cached $value if it's not null, or
                # b) the results of actually calling the user
                # function. Note that we wrap the call in the
                # $store_value function to cache the results,
                # and $store_value passes the value back
                # through as its result and so it is also
                # returned to the user in this case

                return $value ?? $store_value(

                                    $hash, call_user_func_array($func, $params)

                             );
    };

};

Listing 5-3.
memoize.php

```

首先，memoize 函数通过将输入参数编码成 JSON 来制作输入参数的惟一字符串表示。例如，如果您想知道为什么不简单地使用`implode("|", $params)`，请考虑以下两个函数调用:

```
func("Hello","|There");
func("Hello|","There");

```

这将导致两者都被编码为`Hello||There`,因此当它们实际上不同时，被视为相同的参数集。如果你能保证这个字符不会出现在你的参数中，你可以使用带有粘合字符的`implode`,但是为了以防万一，通常编写防御性代码并使用适当的序列化函数是个好主意。您可以使用 PHP 的`serialize()`函数来代替`json_encode`，因为对于某些工作负载，它可能会更快。两者都有边缘情况，你可能想在选择之前熟悉一下，比如`serialize()`不能处理某些类型的对象。关于这两者的更多信息，请参见 PHP 手册。

一旦有了输入的字符串表示，就需要将它转换成适合用作文件名的另一个字符串。您的 JSON 字符串可能包含对文件名无效的字符，因此您将为它创建一个 SHA1 散列。MD5 散列的创建速度稍快，但发生散列冲突的可能性更大(为两个不同的输入生成相同的散列)。即使是 SHA1 也会发生碰撞，尽管风险通常很低。如果您肯定无法处理冲突，那么您将需要编写一些代码来解析序列化的字符串，并以一致的方式替换无效字符，等等，确保您保持在缓存介质的其他限制内(例如，写入磁盘的文件名长度)。

现在您有了自己的散列(或者其他描述输入参数的独特方式)。然后，您尝试从缓存中加载一个以 hash 作为名称的文件的内容。如果您无法读取它(通常是因为它不存在，因为这是您第一次使用这些参数进行调用)，您可以使用`call_user_func_array()`运行 pure 函数，获取它的返回值并创建缓存文件，最后将获取的值作为返回值返回。如果您可以读取该文件，您只需将内容作为返回值返回，并跳过函数的执行。您会注意到这里没有使用任何形式的严格类型。如果你的 pure 函数的返回值是一个`int`(比方说)，当你第一次运行 pure 函数时，你将把它写到磁盘，并把`int`返回给调用者。但是，在随后的运行中，您将缓存文件的内容作为一个字符串获取并返回，因此您的返回值是一个字符串。如果输入在应用程序中很重要，您可以将值序列化到磁盘中，并在读回时再次将其取消序列化。

现在让我们看一个例子，看看如何实际使用这个 memoize 函数。您将使用另一个经典的示例任务，一个生成斐波那契数列的算法。我使用它是因为它是一个简单易懂的函数，而且是递归的。记忆化对任何函数都有效，不管是递归的还是非递归的，但它通常特别有用，因为递归函数经常会占用大量资源，正如您前面看到的那样。如果你不熟悉斐波那契数列，它是一个数列，其中前两个(或者三个，如果你从零开始)后面的每个数字都是前面两个数字的和，所以:

0，1，1，2，3，5，8，13，21，34，55，89，144，233，377，610，987，1597，2584，4181，6765，10946 等等…

该算法取一个整数 n，并计算序列中的第 n 个数。因此，`$fibonacci(7)`将返回 13 (13 是前面序列中的第 7 个数字，从 0 开始)。

您将创建两个函数:一个标准版本的函数和一个包装在早期的`$memoize`函数中的函数。通常你只需要创建一个函数并把它包装在`$memoize`中。然而，因为我想演示一个递归版本，它递归地调用有记忆的版本(并与无记忆的形式进行对比)，所以您将在这里创建两个。由于斐波那契对于现代电脑来说并不是一项特别繁重的任务，你会以`usleep`语句的形式添加一些人为的“费用”来使每次计算花费更长的时间。这将展示记忆化对真正长期运行的函数的影响。参见清单 [5-4](#Par72) 和清单 [5-5](#Par73) 。

```
<?php

# Get our memoize function and helpers

require('memoize.php');

# Define a plain old recursive fibonacci function

$fibonacci =

        function ($n) use (&$fibonacci) {

        usleep(100000); # make this time-expensive!

    return ($n < 2) ? $n : $fibonacci($n - 1) + $fibonacci($n - 2);

    };

# Define the same fibonacci function again in exactly the
# same way (except for the name), but this time wrap the
# function body in a call to $memoize to get a memoized version

$memo_fibonacci = $memoize(

        function ($n) use (&$memo_fibonacci) {

        usleep(100000);

    return ($n < 2) ? $n : $memo_fibonacci($n - 1) + $memo_fibonacci($n - 2);

        }

);

# Let's define a timer function, to time a run of a function,
# and return the parameters, results and timings.

$timer = function($func, $params) {

    $start_time = microtime(true);

    $results = call_user_func_array($func, $params);

    $time_taken = round(microtime(true) - $start_time, 2);

    return [ "Param" => implode($params),
                     "Result" => $results,
                     "Time" => $time_taken ];

};

# And now let's do a set of runs of both our
# ordinary function and it's memoized sister.
# I've added an extra * parameter to the
# non-memoized runs so that you can spot them
# easier in the output (the '*' isn't used
# by the fibonacci functions, it's just passed
# through to the output of the timer function)

print_r( $timer(  $fibonacci, [6, '*'] ) );

print_r( $timer(  $memo_fibonacci, [6] ) );

print_r( $timer(  $fibonacci, [6, '*'] ) );

print_r( $timer(  $memo_fibonacci, [6] ) );

print_r( $timer(  $memo_fibonacci, [10] ) );

print_r( $timer(  $memo_fibonacci, [11] ) );

print_r( $timer(  $memo_fibonacci, [8] ) );

Listing 5-4.
memo_example.php

```

```
Array
(
    [Param] => 6*
    [Result] => 8
    [Time] => 2.5
)
Array
(
    [Param] => 6
    [Result] => 8
    [Time] => 0.7
)
Array
(
    [Param] => 6*
    [Result] => 8
    [Time] => 2.5
)
Array
(
    [Param] => 6
    [Result] => 8
    [Time] => 0
)
Array
(
    [Param] => 10
    [Result] => 55
    [Time] => 0.4
)
Array
(
    [Param] => 11
    [Result] => 89
    [Time] => 0.1
)
Array
(
    [Param] => 8
    [Result] => 21
    [Time] => 0
)
Listing 5-5.memo_example-output.txt

```

如果您查看清单 [5-5](#Par73) 中第一次运行的输出，您会发现标准函数计算第 6 个斐波那契数需要 2.5 秒，而记忆化版本只需要 0.7 秒。当然，它们在第一次运行时应该是相同的，因为还没有任何东西被缓存。因为你的函数是递归的，你实际上在每次计算中多次调用这个函数，当你的内存化版本多次调用相同的参数时，你的缓存将被使用。

第三次运行演示了用参数 6 再次调用标准函数仍然需要 2.5 秒，这是显而易见的，因为它没有缓存。但是，在 6 上调用 memoized 版本需要 0 秒(四舍五入！)因为在计算中每次递归调用都会命中缓存。

接下来计算第 10 个数，你只需要 0.4 秒。这比计算第 6 个数字要快，因为它们共享一些步骤(每个步骤都需要计算第 1、第 2、第 3 等数字)，这些步骤已经被缓存，第 10 个数字只需要实际计算第 7、第 8、第 9 和最后第 10 个数字。下一次运行进一步证明了这一点；计算第 11 个数字现在只需要 0.1 秒(因为它只有一个对函数的未缓存调用)，计算第 8 个数字的最后一次运行在 0 秒内，因为它已经在您生成第 10 个数字时的缓存中。

如果您第二次调用该脚本，您会发现所有使用 memoized 函数的运行都在 0 秒内完成，因为您的缓存已经为所有需要的值准备好了，因为您之前至少生成过一次这些值。除非有人改变数学的基本原理，否则您可以永久保持缓存不变，因为对于给定的输入，缓存的结果总是正确的。如果您想知道缓存是什么样子，运行更多的`/tmp/memo-cache-*`会给出清单 [5-6](#Par78) 中的输出。如您所见，有 12 个文件，这是有意义的，因为您计算了第 11 个斐波那契数(从 0 开始计数),因此调用了具有 12 个不同参数的 memoized 函数。

```
::::::::::::::
/tmp/memo-cache-10ae24979c5028fa873651bca338152dc0484245
5
::::::::::::::
/tmp/memo-cache-1184f5b8d4b6dd08709cf1513f26744167065e0d
0
::::::::::::::
/tmp/memo-cache-1fb0856518ee0490ff78e43d1b6dae12ad6ec686
21
::::::::::::::
/tmp/memo-cache-2499831338ca5dc8c44f3d063e076799bea9bdff
1
::::::::::::::
/tmp/memo-cache-3ad009a144b1e8e065a75ca775c76b2fc2e5ff76
89
::::::::::::::
/tmp/memo-cache-4a0a63ce33cc030f270c607ea7bf90a6717572bb
8
::::::::::::::
/tmp/memo-cache-7a60554107407bfe358bedce2bfcb95c90a8ea0d
34
::::::::::::::
/tmp/memo-cache-8f4e345e7cd51e4e633816f5a52a47df465da189
3
::::::::::::::
/tmp/memo-cache-bd703dc0b11593277a5a82dd893f2880b8d0f32a
13
::::::::::::::
/tmp/memo-cache-e9310b0c165be166c43d717718981dd6c9379fbe
55
::::::::::::::
/tmp/memo-cache-f1e31df9806ce94c5bdbbfff9608324930f4d3f1
2
::::::::::::::
/tmp/memo-cache-f629ae44b7b3dcfed444d363e626edf411ec69a8
1
Listing 5-6.
cache_files.txt

```

在这些例子中，您缓存到磁盘，这允许您创建一个持久的缓存，它可以在重新启动后继续存在，并由多个进程使用。但是，有时磁盘太慢，如果您的函数参数经常变化，您可能只想在单个脚本运行期间进行缓存。另一种方法是在内存中进行缓存，事实上 PHP 提供了一种创建变量的方法，这些变量的行为类似于全局变量，但仅限于给定的函数，非常适合在一次脚本运行中进行缓存。这些被称为静态变量，如果你不熟悉它们，清单 [5-7](#Par80) (和清单 [5-8](#Par81) )是静态变量(`$sta`)的一个例子，与全局变量(`$glo`)、参数变量(`$par`)和普通函数范围变量(`$nor`)相比。

```
<?php

$my_func = function ($par) {

  static $sta;
  global $glo;

  var_dump( "static : ". $sta += 1 );
  var_dump( "global : ". $glo += 1 );
  var_dump( "param  : ". $par += 1 );
  var_dump( "normal : ". $nor += 1 );

  return $sta;

};

while ( $my_func(1) < 5) { echo "-----\n"; };

echo "*****\n";

var_dump( "static : ". $sta );
var_dump( "global : ". $glo );
var_dump( "param  : ". $par );
var_dump( "normal : ". $nor );

Listing 5-7.
static.php

```

```
string(10) "static : 1"
string(10) "global : 1"
string(10) "param  : 2"
string(10) "normal : 1"
-----
string(10) "static : 2"
string(10) "global : 2"
string(10) "param  : 2"
string(10) "normal : 1"
-----
string(10) "static : 3"
string(10) "global : 3"
string(10) "param  : 2"
string(10) "normal : 1"
-----
string(10) "static : 4"
string(10) "global : 4"
string(10) "param  : 2"
string(10) "normal : 1"
-----
string(10) "static : 5"
string(10) "global : 5"
string(10) "param  : 2"
string(10) "normal : 1"
*****
string(9) "static : "
string(10) "global : 5"
string(9) "param  : "
string(9) "normal : "
Listing 5-8.static-output.txt

```

如你所见，即使你每次都用相同的参数(1)调用`my_func`，但是`$sta`的值每次都不一样。因此，虽然您不能从函数之外的任何作用域访问它，但它通常仍被视为“副作用”，因为对于函数的任何特定调用，您都无法确定它将处于什么状态(在这种情况下，不知道函数已经被调用了多少次)。那么，如何在函数式程序中使用静态变量呢？答案是，小心翼翼。让我们来看一个例子(参见清单 [5-9](#Par83) )。您将创建一个版本的 memoize 函数，它使用一个静态数组来保存您的缓存，而不是写入磁盘。

```
<?php

$memoize = function($func)
{

    return function() use ($func)
    {

                static $cache;

        $params = func_get_args();

            $hash = sha1( json_encode( $params ) );

                $cache["$hash"] = $cache["$hash"] ??
                                                    call_user_func_array($func, $params);

                return $cache["$hash"];
    };
};

Listing 5-9.
memoize-mem.php

```

所以，你放入`$cache`数组的所有内容，以及后来从中读取的内容，都完全由你调用函数所用的参数(通过散列)决定，而你放入其中的是那个函数的值。您对静态变量的使用实际上是透明的，所以在这种情况下，您不会产生任何潜在的副作用。如果您像以前一样调用相同的`memoize-example.php`脚本，但是使用这个基于内存的 memoize 函数，您将得到清单 [5-10](#Par85) 中的输出。

```
Array
(
    [Param] => 6*
    [Result] => 8
    [Time] => 2.51
)
Array
(
    [Param] => 6
    [Result] => 8
    [Time] => 0.7
)
Array
(
    [Param] => 6*
    [Result] => 8
    [Time] => 2.51
)
Array
(
    [Param] => 6
    [Result] => 8
    [Time] => 0
)
Array
(
    [Param] => 10
    [Result] => 55
    [Time] => 0.4
)
Array
(
    [Param] => 11
    [Result] => 89
    [Time] => 0.1
)
Array
(
    [Param] => 8
    [Result] => 21
    [Time] => 0
)
Listing 5-10.memo_mem_example-output.txt

```

如您所见，这与基于文件的示例的输出完全相同。它实际上运行得稍微快一点，因为你不做磁盘 I/O，但你在这里四舍五入到最近的 0.1 秒。与基于磁盘的示例相比，另一个唯一的区别是，如果您第二次运行该脚本，您将再次得到这个输出(而不是对于内存化的调用都是零)，因为用于缓存的静态变量在脚本结束时被销毁。

除了磁盘和基于会话的内存缓存之外，还有一种替代方案，即简单的 RAM 磁盘。在 Linux 类型的系统上，有一个名为 tmpfs 的文件系统，它允许您创建和使用存储在内存中而不是磁盘上的文件。这些虚拟文件的行为和操作就像磁盘上的普通文件一样，因此可以允许不同的 PHP 进程读写文件中的缓存数据，就像处理普通的“磁盘上”文件一样。tmpfs 带来的优势是双重的；一是快，二是一切都是暂时的。因为文件保存在内存中，没有机械硬盘等待，所以 I/O 非常快。因为它们保存在内存中，所以它们只是暂时的，如果您没有删除它们，它们会在重新启动时消失。另一个优点是，作为普通文件，它们不是 PHP 特有的技术，因此可以根据需要从其他软件访问。您可以像访问普通文件和流一样访问 tmpfs 文件系统上的文件；它们在内存中的事实对 PHP 脚本是透明的。前面的基于文件的例子在 RAM 磁盘上运行得非常好。

要在 Linux 上创建 tmpfs 文件系统，首先在磁盘上创建一个目录，用于将内存设备“连接”到您的文件系统。然后在该位置安装内存设备并开始使用。清单 [5-11](#Par89) 中的 shell 脚本(清单 [5-12](#Par90) 中的输出)给出了一个安装和移除 tmpfs RAM 磁盘的示例。

```
#!/usr/bin/env bash

mkdir /tmp/myMemoryDrive

sudo mount -t tmpfs /mnt/tmpfs /tmp/myMemoryDrive

php -r "file_put_contents('/tmp/myMemoryDrive/test.txt',\"Hello\n\");"

cat /tmp/myMemoryDrive/test.txt

sudo umount /mnt/tmpfs

cat /tmp/myMemoryDrive/test.txt

Listing 5-11.
ramdisk.sh

```

```
Hello
cat: /tmp/myMemoryDrive/test.txt: No such file or directory
Listing 5-12.ramdisk-output.txt

```

在清单 [5-11](#Par89) 中，您在`/tmp/myMemoryDrive`处创建一个目录来连接内存设备，然后将它安装在那里。您执行一行 PHP 来演示创建一个内存文件，就像创建任何其他文件一样，然后`cat`这个文件，它应该输出`Hello`。最后，你`umount`了设备并试图再次`cat`文件，但正如你所料，文件不见了；它永远不会保存到物理磁盘上。您可以使用`mount`命令挂载 tmpfs 设备，如前面所示，每次启动系统时或任何您想要使用它们的时候，或者您可以在 fstab 文件中添加一个条目，以便在每次系统启动时自动创建它。无论您以何种方式安装它，当您关闭或重新启动时，请始终记住，它以及其中的所有文件都将被销毁。

由于 tmpfs 以与普通文件系统相同的方式运行，您需要确保设置了相关的文件权限，以允许您的所有应用程序访问它(或者防止那些不应该干预它的应用程序访问它)。还要记住，如果您的系统内存不足，可能会发生内存交换到磁盘的情况，因此在这些情况下，您的数据可能会暂时接触到您的硬盘，在某些情况下，之后可能会从磁盘中恢复。始终考虑您选择的任何缓存系统的安全含义。

如果出于性能原因考虑使用 tmpfs 而不是物理硬盘，您还应该记住，现代操作系统(包括现代 Linux)可以使用积极的内存缓存进行磁盘访问。这意味着操作系统透明地将经常读取的基于磁盘的文件缓存到动态分配的未使用的内存中(通常您甚至不知道)，以提高明显的物理磁盘性能。在这些情况下，当从 tmpfs 内存磁盘读取一些文件并在其上遍历目录树时，您可能看不到预期的性能提高。写入磁盘和不经常访问的文件通常不会被缓存，所以在这些情况下，tmpfs 仍然可以为您带来预期的优势。

在 Windows 中，没有内置的方法来创建基于内存的文件系统。有各种各样的第三方软件来创建 RAM 磁盘，但这并不是标准化的，大多数应用程序需要一个 GUI 来在每个系统上手动设置磁盘。如果你仍然感兴趣的话，下面列出的维基百科页面会给你更多的提示。

### 进一步阅读

维基百科上的第三方 RAM 磁盘软件列表

*   [T2`https://en.wikipedia.org/wiki/List_of_RAM_drive_software#Microsoft_Windows`](https://en.wikipedia.org/wiki/List_of_RAM_drive_software#Microsoft_Windows)

### 记忆化的缺点

如你所见，通过记忆化进行缓存通常是一件好事，但正如我母亲常说的，“好东西可以有太多。”默认情况下，开始记忆所有函数的诱惑可能会悄然而至，但是和所有事情一样，首先要考虑一些权衡。您的内存化函数会有一点开销，用于在每次运行时检查缓存版本是否可用，以及获取或存储生成的任何缓存版本。如果您正在进行内存化以加速脚本的执行，并且您的缓存驻留在磁盘上，就像前面的主示例一样，那么磁盘 I/O 的额外时间(与内存存储或实际上许多纯计算函数相比，它通常很慢)可能比运行一个低到中等复杂度的函数要长。当然，如果缓存是为了优化低内存系统，减少对外部 API 的调用次数，或者最小化其他与时间无关的资源使用，这可能是一种可以接受的折衷。

在使用记忆化进行缓存时，需要考虑的另一个问题是，相对于成本而言，某些数据的短暂性是否会限制您从中获得的价值。例如，如果您的函数的参数之一是客户 ID，但是您的客户很少对您的在线商店进行一次以上的访问/购买，则该函数的任何缓存很可能只在那一次访问期间有益。与更一般的缓存情况相比，纯函数内存化的一个好处是，您永远不必担心缓存失效，因为您的缓存永远不会失效。然而，这导致了简单地忘记缓存并让它保持原样的诱惑，从编程的角度来看这是非常好的；您的代码将继续运行良好，输出正确。但是，您的系统管理员可能很快就会过来，开始询问您是否真的需要昂贵的 SAN 上的所有磁盘空间。磁盘空间的成本可能超过脚本的有限加速。在这些情况下，你有三个选择。

*   放弃记忆:接受一些运行时间更长的脚本。
*   缓存到内存或磁盘上的每个会话文件，而不是长期的磁盘存储:这加快了同一访问中的多个调用的速度，但会暂时消耗一些内存。
*   执行某种形式的缓存驱逐:删除缓存的文件，比方说，超过一个月。

## 懒惰评估

懒惰评估是一种艺术，只做尽可能少的工作就能得到你需要的结果。这对一个 PHP 程序员来说应该是很自然的！考虑下面的伪代码:

*   if ( do_something_easy()或 do_something_hard() ) { return }

这段代码表示“如果`do_something_easy()`或`do_something_hard()`为真，则返回。”所以，为了确定你是否应该返回，你可以调用两个函数，如果其中一个返回 true，那么你就知道要返回。然而，考虑到如果`do_something_easy()`返回 true，那么`do_something_hard()`返回什么并不重要，因为在任何情况下你都会返回。所以，在运行了`do_something_easy()`之后，运行第二个函数调用实际上是没有意义的，您可以节省这样做的开销。相反，如果它返回 false，您将需要运行第二个函数，但是这并不比您首先自动调用这两个函数更糟糕。这叫懒评；你只评估你需要的东西，而不是更多的陈述。

PHP 在计算布尔表达式时使用一种称为短路计算的惰性计算，这取决于逻辑运算符的先例。所以，在这里你没有什么要做的，除了记下手册后面的内容，如果你在这样的表达式中调用函数，以确保你没有短路！

### 进一步阅读

PHP 手册:

*   逻辑运算符: [`http://php.net/manual/en/language.operators.logical.php`](http://php.net/manual/en/language.operators.logical.php)
*   运算符优先级: [`http://php.net/manual/en/language.operators.precedence.php`](http://php.net/manual/en/language.operators.precedence.php)

## 发电机

但是，您可以将这种惰性求值的概念应用到您的函数中，以加快速度。在你在前面章节看到的函数组合的例子中，你通常接受一个数据数组，对它做一些事情，把数组传递给下一个函数，做一些其他的事情，等等。即使您实际上并不需要数组中的所有数据，您通常也会传递整个数组，并对整个数组应用您的函数和转换。你看了一下`array_filter`，它使用一些过滤函数将数组的大小减少到特定的元素，但即使这样，过滤函数也应用于数组的每个元素。如果您只需要前 10 个匹配元素，而有 100 个匹配元素，那么在找到前 10 个元素后应用过滤函数就浪费了时间，并且您需要一个额外的步骤，比如使用`array_slice`将结果 100 个元素减少到 10 个。

PHP 有一个很有用的语言工具叫做生成器，它是在 PHP 5.5 中引入的。生成器允许您创建返回类似数组的函数，但其数据是在访问元素时“实时”生成的。您可以使用生成器来创建只做最少必要工作的惰性函数。

当您将生成器函数链接在一起时，执行会向后进行。考虑如下三个标准函数的伪链:

*   `array_filter some_function();`
*   `array_filter another_function();`
*   `array_slice 0, 10;`

首先过滤整个数组，然后再次过滤整个结果，然后第二个结果将减少到 10 项。在基于生成器的系统中，您可以像这样编写一个链:

*   `lazy_filter some_function();`
*   `lazy_filter another_function();`
*   `lazy_slice 0, 10;`

它看起来是一样的，但是当您执行它时，这个动作实际上从`lazy_slice`开始，它通过链向上拉值。slice 函数从第二个过滤器请求值，直到它有十个值。每次第二个过滤器得到一个值的请求，它从第一个过滤器请求值，并对它们应用`another_function()`,直到它有一个匹配。每次第一个过滤器收到一个值的请求时，它从数组中取值，并对它们应用`some_function()`，直到得到一个匹配。因此，当`lazy_slice`得到它的 10 个值时，两个`lazy_filter`函数调用它们的(潜在昂贵的)过滤函数的次数只够产生这 10 个值，而不一定是原始数据的所有项。

一会儿你会看到一个发电机的基本例子。但在此之前，让我们创建一个函数来重复调用一个函数。当您查看计时时，同一台 PC 上不相关的任务可能会暂时降低脚本运行速度。多次运行脚本或函数可以限制这种暂时波动对基准计时数字的影响。参见清单 [5-13](#Par121) 。

```
<?php

# For benchmarking results, it's best to repeatedly run the
# function to minimize the effect of any external slowdowns.
# The following function simply calls a function $func $n times
# with arguments $args, and returns the return value of the last
# call.

$repeat = function ($func, $n, ...$args) {

    for ($i=0; $i < $n; $i++) {

        $result = $func(...$args);

    }

    return $result;

};

Listing 5-13.
repeat.php

```

现在让我们来看一个简单的发电机示例(参见清单 [5-14](#Par124) ，输出如清单 [5-15](#Par125) 所示)。生成器是一个函数，它有一个`yield`语句，而不是一个`return`语句。与返回时会丢失状态的普通函数不同，生成的函数会保持其状态，直到下一次被调用。

PHP 有一个名为`range()`的本地函数，它返回一个从`$start`到`$end`的数字数组，并带有一个可选的`$step`值。您将创建一个生成器版本，`gen_range()`，它产生相同的输出，但是很慢。您将使用相同的参数调用这两个函数，以生成 1 到 1000 万之间的每四个数字，然后当您得到一个可被 123 整除的数字时，退出您正在运行的函数。

```
<?php

# Get our repeat function

require('repeat.php');

# PHP's native function range() takes a
# $start int, $end in and $step value, and
# returns an array of ints from $start to $end
# stepping up by $step each time. We'll create
# a generator version that takes the same
# parameters and does the same task, called gen_range()

function gen_range($start, $end, $step) {

  for ($i = $start; $i <= $end; $i += $step) {

        # yield turns this function into a generator

    yield $i;

  }

};

# We'll create a function to run either range() or
# gen_range() (as specified in $func) with the
# same paramters, and to iterate through the
# returned values until we find a number exactly
# divisible by 123 (which in this case is 369)

$run = function ($func) {

    # Get a range from 1 to ten million in steps of 4,
    # so 1,4,9,13,18,...,9999989,9999993,9999997

  foreach ( $func(1, 10000000, 4) as $n ) {

    if ($n % 123 == 0) {

                # exit the function once we've found one, reporting
                # back the memory in use (as it will be freed once
                # we have returned).

        return memory_get_usage();

    };

  };

};

# A function to get the time/memory use for the runs

$profile = function ($func, ...$args) {

    $start = ["mem" => memory_get_usage(), "time" => microtime(true)];

  $end = ["mem" => $func(...$args),  "time" => microtime(true)];

    return [
           "Memory" => $end["mem"] - $start["mem"],
           "Time" => $end["time"] - $start["time"]
         ];
};

# Finally let's run each of range() and gen_range() 100 times,
# and output the time taken for each and memory used

Echo "*** range() ***\n";

print_r ( $profile($repeat, $run, 100, 'range') );

Echo "*** gen_range() ***\n";

print_r ( $profile($repeat, $run, 100, 'gen_range') );

Listing 5-14.
generators.php

```

```
*** range() ***
Array
(
    [Memory] => 134222280
    [Time] => 8.9564578533173
)
*** gen_range() ***
Array
(
    [Memory] => 4952
    [Time] => 0.0016660690307617
)
Listing 5-15.generators-output.txt

```

所以，你可以看到，懒惰版本使用的内存量比普通的`range()`函数少得多。这是因为在用`foreach`开始遍历它们之前，`range()`必须生成整个值数组，而`gen_range()`只保存序列中的当前值。`gen_range()`花费的时间也少得多，因为一旦你达到 369，你就完成了，而`range()`甚至在你开始之前就必须生成序列中的每一个值。

请注意，使用的内存是当`$run`函数返回时`memory_get_usage`返回的值，对于您的函数来说，这可能是每个函数中使用的最高内存量。

这就是发电机的样子。现在让我们看看如何在函数组合中使用它们，以最小化函数链所要做的工作量。您将创建一个脚本，它获取名副其实的(公共领域)莎士比亚全集(以纯文本文件的形式)，获取提到单词 hero 的行，获取长度超过 60 个字符的行，然后返回前三个匹配项。

清单 [5-16](#Par130) 展示了如何以一种非懒惰的方式来做这件事，输出如清单 [5-17](#Par131) 所示。

```
<?php

# Borrow some functions from Chapter 3,
# and our repeat function

require('../Chapter 3/compose.php');
require('../Chapter 3/partial_generator.php');
require('repeat.php');

# A helper function to fix parameters from the right,
# as we'll otherwise call partial(reverse()) a lot below.

$partial_right = function ($func, ...$params) {

    return partial(reverse($func), ...$params);

};

# Get the start time, to see how long the script takes

$start_time = microtime(true);

# A function to return true if $word is in $str
# (not comprehensive, but matches a word bounded
# by non-A-Z chars, so matches "hero" but not "heroes")

$match_word = function($word, $str) {

    return preg_match("/[^a-z]${word}[^a-z]/i", $str);

};

# A function to return true if $str is longer than $len chars

$longer_than = function($len, $str) {

    return strlen($str) > $len;

};

# A partial function, fixing hero as the word to search for

$match_hero = partial($match_word, 'hero');

# Another partial function, picking out strings longer than 60 chars

$over_sixty = partial($longer_than, 60);

# A partial function which uses array_filter to apply $match_hero
# to all elements of an array and return only those with 'hero' in

$filter_hero = $partial_right('array_filter', $match_hero );

# Similarly, we'll filter an array with the $over_sixty function

$filter_sixty = $partial_right('array_filter', $over_sixty );

# A function to grab the first 3 elements from an array

$first_three = $partial_right('array_slice', 3, 0);

# Let's now compose the function above to create a
# function which grabs the first three long
# sentences mentioning hero.

$three_long_heros = compose(
                                                            $filter_hero,
                                                            $filter_sixty,
                                                            $first_three
                                                 );

# Finally, let's actually call our composed function 100 times
# on the contents of all_shakespeare.txt
# Note that calling file() as a parameter means that it is
# only evaluated once (and not 100 times), so the time for disk
# IO won't be a major element of our timings

$result = $repeat(
                                   $three_long_heros,
                                     file('all_shakespeare.txt'),
                                     100
                                 );

# Print out the result of the last call (which should be the
# same as all of the rest, as all of our composed functions are
# pure and are called on exactly the same input parameter)

print_r($result);

# and the time taken

echo 'Time taken : '.(microtime(true) - $start_time);

Listing 5-16.
filter.php

```

```
Array
(
    [0] =>     Enter DON PEDRO, DON JOHN, LEONATO, FRIAR FRANCIS, CLAUDIO, BENEDICK, HERO, BEATRICE, and Attendants

    [1] =>     Sweet Hero! She is wronged, she is slandered, she is undone.

    [2] =>     Think you in your soul the Count Claudio hath wronged Hero?

)
Time taken : 6.2691030502319

Listing 5-17.filter-output.txt

```

这给了你你正在寻找的三条线，在我的弱不禁风的笔记本电脑上运行 100 次大约需要 6 秒钟。清单 [5-18](#Par133) 以一种懒惰的方式重写了这个脚本，输出如清单 [5-19](#Par134) 所示。

```
<?php

# Again we'll borrow some functions from Chapter 3,
# and our repeat function

require('../Chapter 3/compose.php');
require('../Chapter 3/partial_generator.php');
require('repeat.php');

# and start timing

$start_time = microtime(true);

# We'll now define a lazy version of array_filter, using
# a generator (note the yield statement)

$lazy_filter = function ($func, $array) {

# Loop through the array

    foreach ($array as $item) {

        # Call the function on the array item, and
        # if it evaluates to true, return the item

        if ( $func($item) ) { yield $item; }

    };

};

# The following functions are exactly the same as
# in the non-lazy filter.php example

$match_word = function($word, $str) {

    return preg_match("/[^a-z]${word}[^a-z]/i", $str);

};

$longer_than = function($len, $str) {

    return strlen($str) > $len;

};

$match_hero = partial($match_word, 'hero');

$over_sixty = partial($longer_than, 60);

# Our $filter_hero function is almost the same,
# but note that it calls $lazy_filter instead of
# array_filter (and it uses partial() rather than
# $partial_right, as I've implemented $lazy_filter
# with the parameters in the opposite order to
# array_filter.

$filter_hero = partial($lazy_filter, $match_hero );

# Again $filter_sixty uses $lazy_filter rather than array_filter

$filter_sixty = partial($lazy_filter, $over_sixty );

# As the output from filter_sixty will be a generator object
# rather than an array, we can't use array_slice to
# get the first three items (as data doesn't exist in a
# generator until you call for it). Instead, we'll create
# a $gen_slice function which calls the generator $n times
# and returns the $n returned values as an array. We'll take
# advantage of that fact that a generator is an iterable object,
# and so has current() and next() methods to get each value.
# We'll practice our recursion, rather than just using
# a for loop!

$gen_slice = function ($n, $output = [], $generator) use (&$gen_slice) {

    $output[] = $generator->current();

    $generator->next();

    if ($n > 1) {

                $output = $gen_slice(--$n, $output, $generator);

    }

return $output;

};

# $first_three uses $gen_slice rather than array_slice

$first_three = partial($gen_slice, 3, []);

# We'll compose them together, repeatedly call them
# and output the results using exactly the same
# code as in the non-lazy version

$three_long_heros = compose(
                                                            $filter_hero,
                                                            $filter_sixty,
                                                            $first_three
                                                 );

$result = $repeat( $three_long_heros, file('all_shakespeare.txt'), 100 );

print_r($result);

echo 'Time taken : '.(microtime(true) - $start_time);

Listing 5-18.
lazy_filter.php

```

```
Array
(
    [0] =>     Enter DON PEDRO, DON JOHN, LEONATO, FRIAR FRANCIS, CLAUDIO, BENEDICK, HERO, BEATRICE, and Attendants

    [1] =>     Sweet Hero! She is wronged, she is slandered, she is undone.

    [2] =>     Think you in your soul the Count Claudio hath wronged Hero?

)
Time taken : 2.1842160224915

Listing 5-19.lazy_filter-output.txt

```

你得到了同样的结果，但是只用了微不足道的两秒钟，大约快了三倍。那么，这是如何工作的呢？嗯，你的`lazy_filter`不返回任何数据，而是“产生”一个生成器对象。该对象实现了 PHP 的迭代器接口，因此像`foreach`这样的函数自动知道如何使用它，就像它是任何其他可迭代的数据类型一样。当您使用`gen_slice()`函数时，这一点变得非常明显，它不是假装您正在使用一个数组，而是简单地调用生成器对象的`current()`和`next()`方法来请求接下来的三段数据。如果你不熟悉迭代器，PHP 手册的下一节将会帮你解决。

### 进一步阅读

*   PHP 手册中的`Iterator`类
    *   [T2`http://php.net/manual/en/class.iterator.php`](http://php.net/manual/en/class.iterator.php)

顺便说一句，当我写前面的脚本时，我从`compose`语句开始，命名它链接在一起的三个函数，然后向后工作，找出实现它们需要什么函数。这是您在函数式编程时经常使用的模式；声明性的本质适合于程序设计的自顶向下的方法。

### 懒惰评估的缺点

生成器很棒，一般来说惰性评估是一个非常有用的工具。然而，正如你所料，值得注意的是，这也有不好的一面。如果您再次运行您的`generators.php`示例，但是这次不是寻找一个可被 123 整除的数，而是使用值 9999989，清单 [5-20](#Par141) 和清单 [5-21](#Par142) 显示了会发生什么。

```
*** range() ***
Array
(
    [Memory] => 134222280
    [Time] => 26.05708694458
)
*** gen_range() ***
Array
(
    [Memory] => 4952
    [Time] => 41.604923009872
)

Listing 5-20.generators2-output.txt

```

标准的`range()`函数需要 26 秒，但是你的懒惰的`gen_range()`函数几乎翻倍，达到 41 秒。为什么呢？嗯，发电机有一个固有的开销。寻找一个能被 9999989 整除的数(在这种情况下，就是它本身)意味着你必须一直走到数列的末尾才能找到它。但是你必须对序列中的每个数字调用一个函数(通过`foreach`)，而不是对`range()`调用一个函数，并且每个函数调用都有少量的开销。此外，您调用的函数是由您用 PHP 编写的，而不是由整个 PHP 核心开发团队用 C 编写的，因此不太可能是高度优化的代码。因此，通常会有这样一个时刻，生成器的时间效率比首先进行完整的评估要低。它通常是最小的，并且接近评估过程的末尾，如果您的运行有一个均匀的输入值“分布”,那么您通常会在总体上领先，即使有几个确实比完整的评估方法花费更长的时间。不过，考虑您的用例，并根据真实世界的数据来分析您的代码总是值得的。

不过，也不全是坏消息。如果您看一下内存使用数据，您会发现它们与第一个示例中寻找可被 123 整除的数字完全相同。在这种情况下，如果您在内存受限的设备上工作，您可能会认为每次改变值(而不是预先生成它们)所导致的内存减少值得偶尔的额外执行时间。

## 并行程序设计

在漫长的写书过程中，我常常希望我的每只手都能同时写下不同的章节；那样我会以两倍的速度完成这本书。不幸的是，当我意识到我弱小的大脑一次只能记住一组单词时，我狡猾的计划受挫了。幸运的是，现代计算机不像我这样受限，可以同时执行和跟踪许多任务。计算机以各种方式做到这一点(并行计算、多任务处理、多线程、多重处理等)。)，但都归结为一点:同一时间做的越多，完成事情越快。

然而，事情并不都是美好的，即使当你在同一时间做不同的事情时，现代个人电脑的智能也能让事情井井有条。资源争用、死锁、竞争条件:这些都是当多个线程或进程试图访问相同的资源(变量、数据、文件、硬件等)时发生的事情。)同时。也许像这样编程最难的部分是考虑当你的脚本在不同的路径上执行时可能发生的所有可能性。

函数式编程可以使这变得更容易。当你的程序需要做并行任务的时候，他们会剥离一些线程、子进程或者类似的来完成任务，他们往往会在线程或者进程返回的时候，把结果组合起来或者采取一些行动。如果您使用本书中介绍的功能原则编写这些任务工人，每个任务工人都可以成为一个纯函数链，其中:

*   任务只依赖于给定的输入(比如函数的参数)，而不依赖于任何外部状态。
*   这项任务可以很容易地单独推理，因为它不受其他任务的影响。

这意味着你不必担心(太多)其他任务正在做什么，它们可能正在使用哪些你想要的资源，等等。当您的任务被调用时，它需要的所有东西都作为输入的一部分提供，并且它返回它的输出供父脚本处理/存储等。即使严格来说它不是一个函数，您也可以像它一样编写您的 worker 脚本，接受来自父级的输入，就像它是参数一样，并在最后像返回值一样向父级返回一个值。

PHP 并不适合并行编程，但是有许多方法可以实现并行计算，在需要时可以付诸实施。也许最简单的方法是使用 PHP 内置的进程控制函数并行启动多个 PHP 脚本来完成这项工作。让我们看一个以这种方式使用过程控制的例子。

你要创建一个程序，对莎士比亚全集做一些分析。您将创建一个以正常的线性方式进行分析的函数，以及一个生成多个“客户端”PHP 工作脚本来并行进行分析的函数。首先你会看到你的主`parallel.php`控制脚本，然后你会看到在并行版本中使用的`client.php`脚本，最后你会看到`functions.php`脚本，它包含了各种分析和并行化功能。您的脚本将从文本中挑选出满足特定条件的单词，对这些单词在整个文本中出现的次数进行求和，然后报告该集合中出现的前十个单词。您将重复每个函数 100 次来对它们进行基准测试。

```
<?php

# Get a set of functions that we'll look at shortly

require('functions.php');

# The text to work on.

$shakespeare = file_get_contents('all_shakespeare.txt');

# How many times we're going to run each function, for
# benchmarking purposes

$repeats = 100;

# Compose our single process "standard" function.

$analyze_single = compose(

                    $only_letters_and_spaces, # simplify the text

                    'strtolower', # all lowercase, please

                    $analyze_words, # do the analysis

                    $sort_results, # sort the results

                    'array_reverse', # get the results in descending order

                    $top_ten # return the top ten results
);

# Run the single process version $repeats time on $shakespeare input
# Time the runs

$checkpoint1 = microtime(true);

print_r( $repeat($analyze_single, $repeats, $shakespeare) );

$checkpoint2 = microtime(true);

# Now create a parallel process version

$analyze_parallel = compose (

                    $launch_clients, # Launch a set of client processes to do
                                                     # the analysis

                    $report_clients, # Tell us how many clients were launched

                    $get_results, # Get the results back from the clients

                    $combine_results, # Combine their results into one set

                    $sort_results, # sort the combined results

                    'array_reverse', # get the results in descending order

                    $top_ten # return the top ten results
);

# Run the parallel version and time it

$checkpoint3 = microtime(true);

print_r ( $repeat($analyze_parallel, $repeats, $shakespeare) );

$checkpoint4 = microtime(true);

# Finally, dump the timings for comparison

var_dump( 'Single : '.($checkpoint2 - $checkpoint1));

var_dump( 'Parallel : '.($checkpoint4- $checkpoint3));

Listing 5-21.
parallel.php

```

在`$analyse_parallel`组合中，`$launch_clients`函数将并行启动清单 [5-22](#Par154) 中脚本的多次运行。

```
<?php

require('functions.php');

# Get the chunk of text for the client to analyze
# by reading the contents of STDIN which are piped to
# this script by the fwrite($clients[$key]["pipes"][0], $string)
# line in the $launch_clients function in the parent process

$string = stream_get_contents(STDIN);

# Compose a function to do the analysis. This is the same
# as the first three steps of the single process analysis
# function, with a step to encode the results as JSON at
# the end so we can safely pass them back

$client_analyze = compose(

                                        $only_letters_and_spaces,

                                        'strtolower',

                                        $analyze_words,

                                        'json_encode'

);

# Run the function and write the results to STDOUT,
# which will be read by the stream_get_contents($client["pipes"][1])
# line in the $get_results function in the parent process. In most cases
# you can use echo to write to STDOUT, but sometimes it can be
# redirected, and so explicitly writing like this is better practice

fwrite(STDOUT, $client_analyze($string) );

Listing 5-22.
client.php

```

最后，清单 [5-23](#Par156) 显示了`functions.php`脚本，它实现了您在前面的脚本中编写的所有功能。我把它们分开是为了让脚本更容易阅读，同时也是因为两个脚本都可以访问它们。

```
<?php

# Borrow some utility functions from previous examples

require('../Chapter 3/compose.php');
require('repeat.php');

# To simplify our analysis, replace anything that's not
# a letter with a space.

$only_letters_and_spaces = function($string) {

    return preg_replace('/[^A-Za-z]+/', ' ', $string);

};

# This is the "expensive" deliberately un-optimized function
# that does our "analysis".

$analyze_words = function ($string) {

    # Split our text into an array, one word per element

    $array = preg_split('/ /i', $string, -1, PREG_SPLIT_NO_EMPTY);

    # Filter our array for words that...

    $filtered = array_filter($array, function ($word)  {

        return (

                            # ... contain any of the letters from the word shakespeare

                            preg_match('/[shakespeare]/', $word) != false)

                            # ... AND has at least 1 character in common with this sentence

                            && (similar_text($word, 'William is the best bard bar none') > 1)

                            # ... AND sound like the word "bard"

                            && (metaphone($word) == metaphone('bard'))

                            # ... AND have more than three characters in them

                            && ( (strlen($word) > 3 )

                        );
    });

    # Finally, count up the number of times each of the filtered
    # words appears in the analyzed text, and return that

     return array_count_values($filtered);

};

# Slice the top 10 items off the top of the array

$top_ten = function ($array) {

    return array_slice($array, 0 ,10);

};

# Sort the results numerically

# asort mutates the array, so we wrap it in a function

$sort_results = function($array)  {

            asort($array, SORT_NUMERIC);

            return $array;

};

# The following functions manage the execution of parallel client scripts

# A function to split the text into chunks and launch the
# appropriate number of clients to process it

$launch_clients = function ($string) {

        # Split the string into chunks of 1 million characters,
        # a value which I found by trial and error to give the
        # best results on this machine for this process

        $strings = str_split($string, 1000000);

        # An array to hold the resource identifiers for the client scripts

        $clients = [];

        # Descriptors for "pipes" to read/write the data to/from our client
        # scripts

        $descriptors = [
                                            0 => ["pipe", "r"], #STDIN, to get data
                                            1 => ["pipe", "w"]  #STDOUT, to send data
                                    ];

        # Iterate through the chunks...

        foreach ($strings as $key => $string) {

            # $key will be the array index, 0, 1, 2, 3... etc.
            # We'll use it as a handy way to number our clients

            # Define the command that runs the client

            $command = "php client.php";
            # Open the clients with proc_open. This returns a resource identifier.
            # We'll store it, although our script won't actually use it.

            $clients[$key]["resource"] = proc_open( $command,
$descriptors,
$clients[$key]["pipes"]
                                                                                        );
            # Note the third parameter above is a variable passed by reference.
            # This is used by proc_open to store an array of file pointers
            # identifying PHP's end of the pipes that are created.

            # We use that info here to write our text chunk to. This writes
            # it to STDOUT, and our client script reads it in through STDIN
            # at its end of the pipe.

            fwrite($clients[$key]["pipes"][0], $string);

            # Close the pipe now we're done writing to this client.

        fclose($clients[$key]["pipes"][0]);

        };

        # Once all of the clients have been launched, return their
        # resource identifiers and pipe details

        return $clients;
};

# Simple impure function to report how many clients were
# launched. You could use a writer monad instead if you wanted

$report_clients = function ($clients) {

    # The escape code at the end minimizes our output when
    # when running the script many times, by going up one line
    # and overwriting the output each time.

    echo("Launched ".sizeof($clients)." clients\n\033[1A");

    return $clients;

};

# A function to get the results back from the clients.
# The clients will send a JSON encoded array back to us

$get_results = function ($clients) {

    # An array to gather the results. Each clients' result
    # will be stored as an element of the array

    $results = [];

    # Iterate through the client resource identifiers

    foreach ($clients as $key => $client) {

                # Clients write output to STDOUT, which corresponds to the
                # STDIN Pipe at our end. We'll read that JSON data and
                # decode it to a PHP array. Each client's results will be
                # stored as a separate element of the $results array.

                $results[] = json_decode(

stream_get_contents($client["pipes"][1]),

                                                                true);

                # We've done reading from the client, so we can close the pipe.

                fclose($clients[$key]["pipes"][1]);

            };

            # And finally return all of the results from all of the clients

            return $results;

};

# This function takes the results array from $get_results above and
# combines it into a single array

$combine_results = function ($results) {

# Reduce and return the input array by...

 return   array_reduce($results, function($output, $array) {

        #... iterating over each individual clients results array
        # and either creating or adding the count for each word to
        # the output depending on whether that word already exists in
        # the output

        foreach ($array as $word => $count) {

            isset($output[$word]) ?
                                                $output[$word] += $count  :
                                                $output[$word] = $count ;
          }

        # return $output through to the next iteration of array_reduce

    return $output;

    }, []); # starting with a blank array [] as output

};

Listing 5-23.
functions.php

```

让我们运行`parallel.php`看看会发生什么(参见清单 [5-24](#Par158) )。

```
Array
(
    [beard] => 76
    [bright] => 43
    [buried] => 43
    [bred] => 36
    [breed] => 35
    [bird] => 34
    [bride] => 30
    [broad] => 15
    [bread] => 15
    [board] => 15
)
Launched 4 clients
AArray
(
    [beard] => 76
    [bright] => 43
    [buried] => 43
    [bred] => 36
    [breed] => 35
    [bird] => 34
    [bride] => 30
    [broad] => 15
    [bread] => 15
    [board] => 15
)
string(24) "Single : 48.808692932129"
string(25) "Parallel : 25.10250711441"
Listing 5-24.parallel-output.txt

```

正如您所看到的，您从分析的单个过程和并行过程版本中获得了相同的结果，但是并行版本花费了大约一半的时间来执行。像这样对文本进行分块，可以让四个客户端进程并行地分析所有文本。考虑到该函数的两个版本使用了完全相同的昂贵函数(`$analyze_words`)，您可能会奇怪为什么在四个客户端的情况下，它没有在四分之一的时间内完成。原因是并行运行时有大量的设置工作要做，包括:

*   将文本分成几大块
*   启动新的 PHP 进程
*   写入和读取过程管道
*   最后将结果组合在一起

因此，如果您想进一步加快速度，难道不能简单地并行启动更多的客户端吗？让我们试一试，将文本分成 100，000 个字符的块，这需要 38 个客户端并行计算(参见清单 [5-25](#Par165) )。

```
Array
(
    [beard] => 76
    [bright] => 43
    [buried] => 43
    [bred] => 36
    [breed] => 35
    [bird] => 34
    [bride] => 30
    [broad] => 15
    [bread] => 15
    [board] => 15
)
Launched 38 clients
Array
(
    [beard] => 76
    [bright] => 43
    [buried] => 43
    [bred] => 36
    [breed] => 35
    [bird] => 34
    [bride] => 30
    [broad] => 15
    [bread] => 15
    [board] => 15
)
string(24) "Single : 49.230798959732"
string(26) "Parallel : 145.74519586563"
Listing 5-25.parallel-output2.txt

```

在这种情况下，您的速度从两倍增加到将近三倍长！这也是因为协调所有客户端并将结果汇集在一起的开销。因此，使用这种技术，在给出最大结果的并行进程的数量上，通常有一个最佳点。这在很大程度上取决于手头的任务，对于具有以下特征的函数，您可能会获得更好的结果:

*   结果不需要大量后处理的函数(例如，来自不同客户端的结果的顺序或内容无关紧要)
*   设置成本低廉的功能(例如，拆分输入数据的最少处理，向客户端传输的最少数据)
*   运行时间较长的函数(与函数执行时间相比，时间开销最小)

如您所见，如果没有大量额外的代码来管理并行化，速度就不会提高。在进入代码并行化阶段之前，您可以做许多事情来加快执行速度，包括:

*   使用惰性评估，首先对单词进行计数和排序(廉价操作)，然后将分析作为生成器函数的一部分进行应用
*   重新排序`array_filter`中的操作，以利用 PHP 的惰性求值，在调用更昂贵的`preg_match`之前，先用便宜的函数如`strlen`来缩减数据
*   预先计算`metaphone('bard')`并存储在变量中，而不是每次都计算
*   用更便宜的`strpbrk` PHP 函数替换`preg_match`

如果这还不足以达到您的性能目标，并且您需要进行并行，那么您可以做一些其他的事情来加速并行版本(为了保持代码简单并节省本书的篇幅，我没有这样做)。

*   在每个脚本中只包含您需要的函数，也许使用一个构建步骤来内联它们。
*   直接在共享内存中传递数据，而不是通过管道，这样会更快。
*   不要等到每个客户端都发送了数据之后才继续从下一个客户端读取数据，要以非阻塞的方式反复循环，直到每个客户端都为您准备好了数据。

对于并行脚本来说，惰性评估可能很困难，因为每个脚本都按照适合其本地输入的顺序返回数据，而不一定代表整个数据。例如，使用这个脚本，每个客户端都可以计算自己的最佳结果，但是您不能只接受收到的前十个结果，因为它们可能不是整个莎士比亚作品的前十个结果，而仅仅是那些首先被分析和返回的数据块。正如您所看到的，并行化工作需要一些思考，即使函数式编程通过消除考虑副作用的额外负担来帮助您。也考虑到我甚至还没有谈到如果你的一个客户没有完成或者挂起该怎么办，你就会明白为什么你应该只在真正必要的时候才考虑这种技术。

## 多线程编程

多线程编程的工作方式类似于您在上一节中看到的多进程示例。关键的区别在于并行执行发生在同一个进程中，而不是在不同的进程中。PHP 不是多线程的；但是，使用 Pthreads 扩展可以实现多线程。Pthreads 是一个健壮的基于 OOP 的实现，性能比多进程脚本要好得多；然而，由于共存于同一进程中的线程的性质，它比多进程代码实现起来更复杂。还要注意，Pthreads 扩展只能用于 PHP 的“线程安全”版本，这与许多 PHP 扩展不兼容。Linux 上的大多数包管理器不包含线程安全版本，因此需要您手动编译 PHP(如果您想了解自己编译 PHP 的信息，请参见附录 A)，或者对于 Windows，您需要从 PHP 网站下载线程安全的可执行文件。

尽管如此，采用前面介绍的函数式编程原则将有助于您避开多线程编程中常见的一些问题。关于扩展和使用示例的更多信息可以在 Pthreads 网站上找到。

### 进一步阅读

*   Pthreads 网址: [`http://pthreads.org/`](http://pthreads.org/)
*   PHP 手册中的 Pthreads 部分: [`http://php.net/manual/en/book.pthreads.php`](http://php.net/manual/en/book.pthreads.php)

## 标准 PHP 库(SPL)

在这一章的开始，我讨论了一个事实，即 PHP 的一些明显的性能问题是由于为用户提供易于使用和通用的数据结构和函数所必需的开销。如果您发现这种开销开始限制您的脚本，那么标准 PHP 库(SPL)是一个核心 PHP 扩展，包含常见和深奥的数据结构和函数。这些都是为解决常见的编程问题而设计的，尽管比 PHP 更常见的结构(如普通的 PHP 数组类型)需要更多的思考。在 SPL 中没有什么是函数式编程独有的，而是有一些有用的函数和结构可以用在你在本书中看到的函数式技术中。

因此，举例来说，如果您发现传递大型数据数组会导致您的脚本达到内存极限，那么您可能希望查看一下`SplFixedArray`类。它有一些限制(您只能使用整数作为索引，并且必须预先指定数组的长度)，但它提供了一个比普通数组使用更少内存的更快的实现。如果您不熟悉 SPL 中的一些数据结构(如堆、链表等)。)，那么最基本的计算机科学入门(或者用更传统的语言编程)应该能帮到你。SPL 还包含用于常见的基于迭代器的任务的函数和类，您可以将这些函数和类与您之前看到的生成器一起使用。

清单 [5-26](#Par188) 中的示例脚本让您领略了`iterator_to_array`函数、`SplFixedArray`结构和`FilterIterator`类。

```
<?php

# Borrow our simple generator example

function gen_range($start, $end, $step) {

  for ($i = $start; $i <= $end; $i += $step) {

    yield $i;

  }

};

# Call the generator...

$gen_obj = gen_range(1,10,1);

# ... and check what we have is a generator object
print_r($gen_obj);

# Generators are iterators, so when we need a full array
# of data instead of a generator, we can convert
# it to an array using SPL's iterator_to_array function

$array = iterator_to_array($gen_obj);

print_r($array);

# An SplFixedArray is SPLs fixed size array data structure.
# Let's create an empty SPL fixed array and a standard PHP array.
# Note we need to specify a size for the SPL array

$spl_array = new SplFixedArray(10000);

$std_array = [];

# Let's create a function to fill an array with data. As both
# array types can be written to in the same way, we can
# use the same function here for both

$fill_array = function($array, $i = 0) use (&$fill_array) {

    # recursively fill the $array with data

    if ($i < 10000) {

        $array[$i] = $i * 2;

        return $fill_array($array, ++$i);

    };

    return ($array);

};

# Let's do some operations with the arrays. We'll measure
# the memory in use before and after each operation.

$mem1 = memory_get_usage();

# Fill the standard array with data

$std_array = $fill_array($std_array);

$mem2 = memory_get_usage(); # 528384 bytes

# Fill the SPL array with data

$spl_array = $fill_array($spl_array);

$mem3 = memory_get_usage(); # 0 bytes

# It took no memory to fill!
# This is because this type of array allocates all of its memory
# up-front when you create it

# Create a new SPL array and fill with data

$spl_array2 = new SplFixedArray(10000);

$spl_array2 = $fill_array($spl_array2);

$mem4 = memory_get_usage(); # 163968 bytes

# This time it did, as we declared it within the section we
# were measuring

# Create a new empty standard array

$std_array2 = [];

$mem5 = memory_get_usage(); # 56 bytes - a small amount

# Create a new empty SPL array

$spl_array3 = new SplFixedArray(10000);

$mem6 = memory_get_usage(); # 163968 bytes - for an empty array!

# This shows that you need to use it with care. A Standard
# array may use more memory for the same amount of data, but
# the memory also shrinks with the array contents too.

echo "Filled Standard Array : ".($mem2 - $mem1). " bytes \n";

echo "1st Filled SPLFixedArray : ".($mem3 - $mem2). " bytes \n";

echo "2nd Filled SPLFixedArray : ".($mem4 - $mem3). " bytes \n";

echo "Empty Standard Array : ".($mem5 - $mem4). " bytes \n";

echo "Empty SPLFixedArray : ".($mem6 - $mem5). " bytes \n";

# The SPL provides various iterator classes that you can extend
# to work with iterable structures like the SPLFixedArray and
# generators

# Let's create a class to filter for values that are divisible by three

class by_three extends FilterIterator {

    # We extend the FilterIterator class, and implement the accept() class
    # with your filtering function

  public function accept()
  {

    $value = $this->current();

    if ($value % 3 == 0) {

            # return true to include the value in the output

      return true;

    }

         # or false to filter it out

    return false;
  }

};

# Let's use it to filter our previous SPL array

$nums = new by_three($spl_array);

var_dump(iterator_count($nums)); # int(3334) (∼third of the array is returned)

Listing 5-26.spl.php

```

SPL 中还有更多可用的类、函数和数据结构。查看 PHP 手册了解更多细节。

### 进一步阅读

*   PHP SPL 文档
    *   [T2`www.php.net/manual/en/book.spl.php`](http://www.php.net/manual/en/book.spl.php)

## 结论

在本章中，您了解了函数式编程在性能改进领域的一些常见应用。即使您没有完全用功能代码编写应用程序，挑选出导致瓶颈的关键功能，并根据功能原则重写它们，也可以让您将这些性能增强技术应用到这些代码部分。当然，如果你用函数式风格从头开始编写你的应用程序，当你发现一个有问题的函数时，应用诸如记忆化之类的技术是快速而简单的。